from __future__ import annotations

import argparse
import json
import os
import re
import time
from pathlib import Path
from typing import Dict, Iterable, List, Optional

import requests
from bs4 import BeautifulSoup
from dotenv import load_dotenv

try:  # Optional dependency for AI summarisation
    import google.generativeai as genai
except Exception:  # pragma: no cover - library is optional
    genai = None

load_dotenv()

DEFAULT_OUTPUT = Path(__file__).parent / "data" / "attractions.json"

def summarize_text(text: str) -> str:
    """Return an AI generated summary of *text* if possible.

    The function uses Google's Generative AI models if the optional
    dependency and an API key (``GOOGLE_API_KEY`` env var) are available.
    If not, the original text is returned unchanged.
    """

    if not text or genai is None:
        return text

    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        return text

    try:  # pragma: no cover - network call
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel("gemini-2.5-flash")
        prompt = (
            "Summarize the following tourist attraction description in one "
            "concise sentence:\n" + text
        )
        response = model.generate_content(prompt)
        return response.text.strip() if getattr(response, "text", None) else text
    except Exception:
        return text


def parse_attraction_gemini(prompt: str) -> Dict[str, Optional[str]]:
    """Use Google Generative AI to generate attraction data from a prompt."""
    if genai is None:
        raise RuntimeError("Google Generative AI library not installed.")
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise RuntimeError("GEMINI_API_KEY environment variable not set.")
    genai.configure(api_key=api_key)
    model = genai.GenerativeModel("gemini-2.5-flash")
    response = model.generate_content(prompt)
    # Expecting a JSON string in response.text
    try:
        return json.loads(response.text)
    except Exception:
        return {"raw": response.text}


def scrape_attractions_gemini(prompts: List[str]) -> List[Dict[str, Optional[str]]]:
    """Generate attraction data using Google Generative AI for each prompt."""
    return [parse_attraction_gemini(prompt) for prompt in prompts]


def group_by_district(
    attractions: Iterable[Dict[str, Optional[str]]]
) -> Dict[str, Dict[str, List[Dict[str, str]]]]:
    """Group attractions by district in the application's JSON format."""

    result: Dict[str, Dict[str, List[Dict[str, str]]]] = {}
    for attr in attractions:
        district = attr.get("district") or "Unknown"
        entry = result.setdefault(
            district, {"description": "", "attractions": []}
        )
        entry["attractions"].append(
            {
                "name": attr.get("name", ""),
                "desc": attr.get("desc", ""),
                "image": attr.get("image", ""),
                **(
                    {"summary": attr["summary"]}
                    if attr.get("summary")
                    else {}
                ),
            }
        )
    return result


def save_json(
    data: Dict[str, Dict[str, List[Dict[str, str]]]], path: Path
) -> None:
    """Write *data* to *path* as JSON."""

    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


def run(output: Path, prompts: List[str]) -> None:
    """Generate attraction data using Google Generative AI and save as JSON."""
    attractions = scrape_attractions_gemini(prompts)
    # For compatibility, group all under 'AI Generated'
    grouped = {"AI Generated": {"description": "Generated by Gemini AI", "attractions": attractions}}
    save_json(grouped, output)


def main(argv: Optional[List[str]] = None) -> None:
    """Command line interface for the Gemini AI scraper."""
    parser = argparse.ArgumentParser(description="Generate Sabah attractions using Gemini AI")
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT,
        help="Path to write attractions JSON (default: %(default)s)",
    )
    parser.add_argument(
        "--prompt",
        type=str,
        action="append",
        help="Prompt describing the attraction (can be used multiple times)",
    )
    args = parser.parse_args(argv)
    prompts = args.prompt if args.prompt else [
        "Describe Mount Kinabalu as a tourist attraction in Sabah, Malaysia. Return JSON with keys: name, desc, image, district, summary.",
        "Describe Sipadan Island as a tourist attraction in Sabah, Malaysia. Return JSON with keys: name, desc, image, district, summary.",
        "Describe Gaya Street Sunday Market in Kota Kinabalu, Sabah. Return JSON with keys: name, desc, image, district, summary.",
        "Describe Tawau Hills Park in Tawau, Sabah. Return JSON with keys: name, desc, image, district, summary.",
        "Describe Poring Hot Springs in Ranau, Sabah. Return JSON with keys: name, desc, image, district, summary.",
        "Describe Kinabatangan River Cruise in Kinabatangan, Sabah. Return JSON with keys: name, desc, image, district, summary.",
        "Describe Sabah Art Gallery in Kota Kinabalu, Sabah. Return JSON with keys: name, desc, image, district, summary.",
        "Describe Mari Mari Cultural Village in Kota Kinabalu, Sabah. Return JSON with keys: name, desc, image, district, summary.",
        "Describe Muzium Sabah in Kota Kinabalu, Sabah. Return JSON with keys: name, desc, image, district, summary."
    ]
    run(args.output, prompts)


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    main()
